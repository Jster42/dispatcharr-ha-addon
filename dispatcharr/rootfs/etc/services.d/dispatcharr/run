#!/usr/bin/with-contenv bash
set -euo pipefail

# Ensure DISPATCHARR_ENV is set for aio mode
export DISPATCHARR_ENV="${DISPATCHARR_ENV:-aio}"

# Ingress configuration - service must bind to 0.0.0.0:9191 for Home Assistant Ingress
# The entrypoint.sh script uses DISPATCHARR_PORT to configure nginx (see docker/init/03-init-dispatcharr.sh)
# It replaces NGINX_PORT placeholder in nginx.conf with DISPATCHARR_PORT value
export DISPATCHARR_PORT=9191

# For entrypoint.aio.sh (Gunicorn mode)
export GUNICORN_PORT=9191
export GUNICORN_BIND="0.0.0.0:9191"

# Additional environment variables for compatibility
export PORT=9191
export HOST=0.0.0.0

# Debug: List all possible entrypoint locations
echo "=== Searching for entrypoint scripts ===" >&2
for ep in /entrypoint.aio.sh /entrypoint.sh /app/docker/entrypoint.sh /docker-entrypoint.sh; do
    if [ -f "$ep" ]; then
        echo "Found: $ep" >&2
        ls -la "$ep" >&2
    fi
done

echo "=== Ingress Configuration ===" >&2
echo "DISPATCHARR_PORT: $DISPATCHARR_PORT (nginx will listen on this port)" >&2
echo "GUNICORN_PORT: $GUNICORN_PORT (for aio mode)" >&2
echo "DISPATCHARR_ENV: $DISPATCHARR_ENV" >&2

# Priority order: /app/docker/entrypoint.sh (actual) > entrypoint.aio.sh > entrypoint.sh
if [ -f /app/docker/entrypoint.sh ]; then
    echo "Starting Dispatcharr with /app/docker/entrypoint.sh" >&2
    echo "  Environment: $DISPATCHARR_ENV" >&2
    echo "  DISPATCHARR_PORT: $DISPATCHARR_PORT (nginx will listen on 0.0.0.0:$DISPATCHARR_PORT)" >&2
    echo "  Note: The entrypoint will replace NGINX_PORT in nginx.conf with $DISPATCHARR_PORT" >&2
    echo "  Note: We will patch nginx config to explicitly bind to 0.0.0.0 for Ingress compatibility" >&2
    
    # Verify nginx config after entrypoint runs (as a backup check)
    # The cont-init.d script should have already patched the template,
    # but we verify here as a safety check
    (
        # Wait for init script to create nginx config (init script runs early in entrypoint)
        sleep 8
        nginx_conf="/etc/nginx/sites-enabled/default"
        
        # Wait for config file to exist (init script creates it)
        for i in {1..15}; do
            if [ -f "$nginx_conf" ]; then
                break
            fi
            sleep 1
        done
        
        if [ -f "$nginx_conf" ]; then
            # Verify it has the correct binding (should already be set from template patching)
            if ! grep -q "listen[[:space:]]*0\.0\.0\.0:$DISPATCHARR_PORT" "$nginx_conf" 2>/dev/null; then
                echo "⚠️ Warning: Nginx config doesn't have 0.0.0.0 binding, patching now..." >&2
                # Replace "listen 9191;" with "listen 0.0.0.0:9191;" as fallback
                sed -i.bak "s/listen[[:space:]]*$DISPATCHARR_PORT;/listen 0.0.0.0:$DISPATCHARR_PORT;/g" "$nginx_conf" 2>/dev/null
                sed -i.bak "s/listen[[:space:]]*$DISPATCHARR_PORT[[:space:]]*default_server;/listen 0.0.0.0:$DISPATCHARR_PORT default_server;/g" "$nginx_conf" 2>/dev/null
                rm -f "${nginx_conf}.bak" 2>/dev/null || true
                
                # Reload nginx if it's already running to apply changes
                if command -v nginx >/dev/null 2>&1 && pgrep nginx >/dev/null 2>&1; then
                    echo "Reloading nginx to apply Ingress binding changes" >&2
                    nginx -s reload 2>/dev/null || true
                fi
            fi
            
            # Verify nginx is actually listening on the correct port
            sleep 3
            echo "Verifying nginx configuration..." >&2
            echo "Current nginx listen directive:" >&2
            grep "listen" "$nginx_conf" | head -1 >&2
            echo ""
            
            if command -v ss >/dev/null 2>&1; then
                echo "Checking if nginx is listening on port $DISPATCHARR_PORT..." >&2
                LISTEN_CHECK=$(ss -tlnp 2>/dev/null | grep ":$DISPATCHARR_PORT " || true)
                if [ -n "$LISTEN_CHECK" ]; then
                    echo "✅ Nginx is listening: $LISTEN_CHECK" >&2
                else
                    echo "⚠️ Warning: nginx may not be listening on port $DISPATCHARR_PORT" >&2
                fi
            elif command -v netstat >/dev/null 2>&1; then
                echo "Checking if nginx is listening on port $DISPATCHARR_PORT..." >&2
                LISTEN_CHECK=$(netstat -tlnp 2>/dev/null | grep ":$DISPATCHARR_PORT " || true)
                if [ -n "$LISTEN_CHECK" ]; then
                    echo "✅ Nginx is listening: $LISTEN_CHECK" >&2
                else
                    echo "⚠️ Warning: nginx may not be listening on port $DISPATCHARR_PORT" >&2
                fi
            fi
            echo ""
            
            # Test HTTP connection to nginx
            echo "Testing HTTP connection to nginx..." >&2
            if command -v curl >/dev/null 2>&1; then
                # Test with longer timeout to catch slow responses
                HTTP_TEST=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 --connect-timeout 5 http://localhost:$DISPATCHARR_PORT/ 2>&1 || echo "FAILED")
                if [ "$HTTP_TEST" = "200" ] || [ "$HTTP_TEST" = "301" ] || [ "$HTTP_TEST" = "302" ] || [ "$HTTP_TEST" = "404" ]; then
                    echo "✅ Nginx is responding to HTTP requests (HTTP $HTTP_TEST)" >&2
                    
                    # Check response headers for potential issues
                    echo "Checking response headers..." >&2
                    CONTENT_LENGTH=$(curl -s -I --max-time 10 http://localhost:$DISPATCHARR_PORT/ 2>/dev/null | grep -i "content-length:" | sed 's/.*: *//' | tr -d '\r' || echo "")
                    ACTUAL_SIZE=$(curl -s --max-time 10 http://localhost:$DISPATCHARR_PORT/ 2>/dev/null | wc -c || echo "0")
                    
                    if [ -n "$CONTENT_LENGTH" ] && [ "$CONTENT_LENGTH" != "0" ]; then
                        echo "  Content-Length header: $CONTENT_LENGTH bytes" >&2
                        echo "  Actual response size: $ACTUAL_SIZE bytes" >&2
                        if [ "$CONTENT_LENGTH" != "$ACTUAL_SIZE" ]; then
                            echo "  ⚠️ Warning: Content-Length mismatch! This could cause Ingress issues." >&2
                        fi
                    fi
                    
                    # Check for Transfer-Encoding chunked (can cause issues with some proxies)
                    TRANSFER_ENCODING=$(curl -s -I --max-time 10 http://localhost:$DISPATCHARR_PORT/ 2>/dev/null | grep -i "transfer-encoding:" || echo "")
                    if [ -n "$TRANSFER_ENCODING" ]; then
                        echo "  Transfer-Encoding: $TRANSFER_ENCODING" >&2
                    fi
                elif [ "$HTTP_TEST" = "000" ] || [ "$HTTP_TEST" = "FAILED" ]; then
                    echo "⚠️ Warning: Nginx is not responding to HTTP requests" >&2
                    echo "  This could indicate:" >&2
                    echo "  - uWSGI socket not ready" >&2
                    echo "  - Nginx configuration issue" >&2
                    echo "  - Service not fully started" >&2
                    echo "  - Connection timeout (check uWSGI socket)" >&2
                    # Check if uWSGI is actually running
                    if pgrep uwsgi >/dev/null 2>&1; then
                        echo "  Note: uWSGI process is running" >&2
                    else
                        echo "  ⚠️ uWSGI process not found!" >&2
                    fi
                else
                    echo "⚠️ Nginx returned HTTP $HTTP_TEST" >&2
                fi
            else
                echo "curl not available, skipping HTTP test" >&2
            fi
            echo ""
            
            # Check uWSGI socket
            echo "Checking uWSGI socket..." >&2
            if [ -S /app/uwsgi.sock ]; then
                echo "✅ uWSGI socket exists: /app/uwsgi.sock" >&2
                ls -la /app/uwsgi.sock >&2
            else
                echo "⚠️ Warning: uWSGI socket not found at /app/uwsgi.sock" >&2
            fi
            echo ""
            
            # Show nginx error log if available
            if [ -f /var/log/nginx/error.log ]; then
                ERROR_COUNT=$(tail -50 /var/log/nginx/error.log 2>/dev/null | wc -l)
                if [ "$ERROR_COUNT" -gt 0 ]; then
                    echo "Recent nginx errors (last 5):" >&2
                    tail -5 /var/log/nginx/error.log >&2
                else
                    echo "No recent nginx errors" >&2
                fi
            fi
        else
            echo "⚠️ Warning: Nginx config file not found at $nginx_conf after waiting" >&2
        fi
    ) &
    
    # Start the entrypoint (this will block)
    exec /app/docker/entrypoint.sh
elif [ -f /entrypoint.aio.sh ]; then
    echo "Starting Dispatcharr with /entrypoint.aio.sh" >&2
    echo "  Environment: $DISPATCHARR_ENV" >&2
    echo "  GUNICORN_PORT: $GUNICORN_PORT (should bind to 0.0.0.0:$GUNICORN_PORT)" >&2
    exec /entrypoint.aio.sh
elif [ -f /entrypoint.sh ]; then
    echo "Starting Dispatcharr with /entrypoint.sh" >&2
    echo "  Environment: $DISPATCHARR_ENV" >&2
    echo "  GUNICORN_PORT: $GUNICORN_PORT (should bind to 0.0.0.0:$GUNICORN_PORT)" >&2
    exec /entrypoint.sh
else
    echo "ERROR: No entrypoint script found. Checked:" >&2
    echo "  - /app/docker/entrypoint.sh" >&2
    echo "  - /entrypoint.aio.sh" >&2
    echo "  - /entrypoint.sh" >&2
    echo "Available files in /app/docker/:" >&2
    ls -la /app/docker/ 2>&1 || true
    exit 1
fi
